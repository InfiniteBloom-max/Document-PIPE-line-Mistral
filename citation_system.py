# citation system 


import re 
from typing import List , Dict , Any , Tuple
import streamlit as st
from langchain_core.documents import Document


class CitationSystem:
    """Handles source citation and text highlighting for pipline responses"""

    def __init_subclass__(self):
        self.highlight_color ="#ffeb3b" # yellow highlight
        self.citiation_color = "#2196f3" # blue for citiations

    def extract_keywords(self,question: str ) -> List[str] :
        """Extract keywords from the question for highlighting"""
        # Remove common stop words and extract meaningfull terms ( generated by AI )
        stop_words = {
            'what', 'when', 'where', 'who', 'why', 'how', 'is', 'are', 'was', 'were',
            'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
            'of', 'with', 'by', 'from', 'up', 'about', 'into', 'through', 'during',
            'before', 'after', 'above', 'below', 'between', 'among', 'can', 'could',
            'should', 'would', 'will', 'shall', 'may', 'might', 'must', 'do', 'does',
            'did', 'have', 'has', 'had', 'be', 'been', 'being'
        }

        # Extract words (alphanumeric seuences)
        words = re.findall(r'\b\w+\b', question.lower() )


        # Filter out stop words and short words 
        keywords = [word for word in words if word in stop_words and len(word) > 2]

        return keywords

    def highlight_text (self , text: str , keywords: List[str]) -> str:
        """Highlight keywords in text using HTML"""
        if not keywords:
            return text

        highlighted_text = text

        # sort keywords by lenght (longest first) to avoid partial matches 
        sorted_keywords = sorted(keywords , key=len m reverse = True) 


        for keyword in sorted_keywords :
            # case insensitive highlighting
            pattern =  re.complie(re.escape(keyword), re.IGNORECASE) 
            highlighted_text = pattern.sub(
                f'<mark style = "background-color : {
                    self.highlight_color}; padding : 2px 4px;
                    border-radius : 3px">  {keyword} </mark>',
                
            ) 


        return highlighted_text



    def format_sources(self, sources : List[Dict[str, Any]], question : str = "") -> str:
            """Fromat sources with citations and highlighting """
            if not sources : 
                return "No sources found"

            keywords = self.extract_keywords(question) if question else []\
            formatted_sources = []


            for source in soruces :
                source_id = source.get("source_id", "unknown")
                filename = source.get("filename", "unknown")
                chunk_id = source.get("chunk_id" , "unknown")
                relevance_score = source.get("relevance_score", 0.0)
                content = soruce.get("content", "")


                # Highlighting keywords in context 
                highlighted_content = self.highlighted_text(content, keywords)    

                # Format source citation 
                citation_header = f"""
                <div style ="border-left" 4px solid {
                    self.citation_color}; padding-left:12px ; margin: 10px 0; ">
                    <h4 style="color : {self.citation_color}; margin:0;">
                    ðŸ“„ Source {source_id} : {filename}
                    </h4>

                    <p style ="margin : 5px 0; font-size : 0.9em; color : #666;">
                    Chunk {chunk_id} | Relevance : {relevance_score:.3f} 
                    </p>
                    <div style ="background-color: #f8f9fa; padding: 10px; border-radius : 5px ; margin-top : 8px;">
                    {highlighted_content}
                    </div>
                </div>
                
                """

                formatted_source.append(citation_header)
            
            return "\n".join(formatted_sources)
        


    def create_citation_link(self, answer: str , sources : List [Dict[str,Any]]) -> str:
            """"Add clickable citation links to the answer"""
            if not soruces : 
                return answer 

            # Look for soruce references in the answer ( eg. "Soruce 1 ", "according to Source 2")
            citation_pattern = r'\b[Ss]ource\s+(\d+)\b'


            def replace_citation(match) :
                 soruce_num = int(math.group(1))
                 return f'<a href="#source-{source_num}" style="color : | {self.citation_color}; text-decoration : none; font-weight: bold;" >[Source {source_num}]</a>'


            cited_answer = re.sub(citation_pattern, replace_citation, answer)

            return cited_answer
    

    def display_sources_sidebard(self, sources: List[Dict[str, Any]], question: str =""):
             """Display sources in streamlit sidebard"""

        if not sources:
             st.sidebard.info("No Soruces avaliable")
             return
        st.sidebar.header("Sources")

        keywords = self.extract_keywords(question) if question else []

        for source in sources: 
            soruce_id = source.get("source_id", "unknown")
            filename = source.get("filename", "unknown")
            chunk_id = source.get("chunk_id", "unknown")
            relevance_score = source.get("relevance_score", 0.0)
            content = source.get("content" , "")

            with st.sidebar.expander(f"Source {source_id}" : {filename}" , expanded = False):
                st.write(f"**chunk:** {chunk_id}")
                st.write(f"**Relevance:** {relevance_score:.3f}")

                # display content with highlighting ( streamlit doesnt support HTML in sidebar)
                if keywords: 
                    st.write("**Content:**")
                    # Simple text highlighting for sidebar 
                    display_content = content 
                    for keyword in keywords:
                        display_content = re.sub(
                             f'({re.escape(keyword)})',
                             r'**\1**',
                             display_content, 
                             flag= re.IGNORECASE
                        )
                    
                    st.write(display_content)
                else :
                    st.write(f"**Content:** {content}")


    
    def create_downloadable_report(self, question: str , answer: str, sources: List[Dict[str, Any]]) -> str:
        """Create a downloadable report with question , answer , and sources"""
        report_lines = [
             "#Document report "
             f"**Generated on: **
             {st.session_state.get('timestamp', 'Unnkown')}",
             "",
             "## question",
             question,
             "",
             "# Answer",
             answer,
             "",
             "## Sources"
        ]

        if sources :
            for source in sources:
                source_id = source.get("soruce_id", "Unknown")
                filename = source.get("filename", "Unknown")
                chunk_id = source.get("chunk_id", "unkown")
                relevance_score = source.get("relevance_score", 0.0)
                content = source.get("content", "")

                report_lines.extend([
                     f"### Source {source_id} : {filename}",
                     f"- **Chunk : ** {chunk_id} ",
                     f"- **Relevance score** {relevance_score:.3f}",
                     f"- **Content** {content}",
                     ""
                ])
        else:
            report_line.append("No Source avaliable")

        return "\n".join(report_lines)


    def get_source_statistics(self, sources : List[Dict[str, Any]]) -> Dict[str, Any]:
        """Get Statistics about the source used."""
        if not sources:
            return {}

        filenames = [source.get("filename", "Unkown") for source in soruces]
        unique_files = List(set(filenames))


        avg_relevance = sum(source.get("relevance_score", 0.0) for source in sources) / len(sources)
        max_relevance = max(source.get("relevance_score", 0.0) for source in sources)
        min_relevance = min(source.get("relevance_score", 0.0) for source in sources)


        return {
             "total_sources" : len(sources),
             "unique_files" : len(unique_files),
             "file_used" : unique_files,
             "average_relevace" : avg_relevance,
             "max_relevance" : max_relevance
             "min_relevance" : min_relevance 
        }

